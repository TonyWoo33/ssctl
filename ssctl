#!/usr/bin/env bash
# ssctl - Shadowsocks control plane for user-level systemd
# Version: 3.0.0

set -Eeuo pipefail
shopt -s nullglob

APP_NAME="ssctl"
APP_VERSION="3.2.0"
CONF_DIR="${HOME}/.config/shadowsocks-rust"
export NODES_DIR="${CONF_DIR}/nodes"
export CURRENT_JSON="${CONF_DIR}/current.json"
export SYS_DIR="${HOME}/.config/systemd/user"

if [ -z "${SSCTL_SELF_PATH:-}" ]; then
  case "$0" in
    /*) SSCTL_SELF_PATH="$0" ;;
    *)
      SSCTL_SELF_PATH="$(cd "$(dirname "$0")" 2>/dev/null && pwd -P)/$(basename "$0")"
      ;;
  esac
  export SSCTL_SELF_PATH
fi

# Shadowsocks binary names
export BIN_RUST="sslocal"      # shadowsocks-rust
export BIN_LIBEV="ss-local"    # shadowsocks-libev

export DEFAULT_LOCAL_ADDR="127.0.0.1"
export DEFAULT_LOCAL_PORT="1080"
export DEFAULT_PROBE_URL="https://www.google.com/generate_204"
export PROBE_IP_LOOKUP_URL="${SSCTL_PROBE_IP_URL:-https://ifconfig.me}"
export PROBE_COUNTRY_LOOKUP_URL="${SSCTL_PROBE_COUNTRY_URL:-https://ipinfo.io/country}"

# 等待端口监听（最多 N 秒）
wait_listen(){
  local name="$1" timeout="${2:-8}"
  local laddr lport
  laddr="$(json_get "$name" local_address)"; [ -n "$laddr" ] || laddr="$DEFAULT_LOCAL_ADDR"
  lport="$(json_get "$name" local_port)";   [ -n "$lport" ] || lport="$DEFAULT_LOCAL_PORT"

  local i=0
  while [ "$i" -lt "$timeout" ]; do
    if command -v nc >/dev/null 2>&1; then
      nc -z "$laddr" "$lport" -w 1 && return 0
    else
      (exec 3<>"/dev/tcp/${laddr}/${lport}") 2>/dev/null && { exec 3>&-; return 0; }
    fi
    sleep 1; i=$((i+1))
  done
  return 1
}

show_version(){
  echo "${APP_NAME} ${APP_VERSION}"
}

short_usage(){
  cat <<'U'
用法：ssctl [全局选项] <命令> [节点名]

全局选项：
  --config FILE        指定配置文件（默认 ~/.config/ssctl/config.json）
  --color on|off|auto  覆盖颜色策略

命令（简洁版）：
  add <name> [--from-file FILE | --server HOST --port N --method M --password P
              [--local-port N] [--engine E] [--plugin X] [--plugin-opts Y]]
              新增/导入节点（不自动启动；若 current 未设置，会指向新节点）

  remove <name> [--purge] [-y|--yes]
              移除节点：停止并删除 unit、删除 _libev_ 兼容文件；
              默认保留 nodes/<name>.json；带 --purge 同时删除主配置

  start [name]  启动（含自检/单实例/自动生成 unit/启动后探测）
  stop  [name]  停止当前/指定节点
  switch <name>|--best 切换或自动择优“当前节点”（仅切换，不启动）
  list          用表格列出所有节点（RUN 状态/端口/算法/引擎/UNIT）
  show [name] [--qrcode]
              查看节点配置、状态或生成二维码

  monitor [name] [--url URL] [--interval N] [--count M] [--no-dns]
              [--ping] [--format json|text] [--tail] [--log]
              [--speed] [--stats-interval S] [--filter key=value]
              [--auto-switch] [--fail-threshold=N]
              实时监控：连通性/时延/速率/成功率，可选输出日志与速率
  stats [name|all] [--interval S] [--count N] [--aggregate] [--format text|json]
              采集实时上下行速率与累计量，可按节点或汇总输出
  logs [name] [--follow] [--filter key=value] [--format text|json]
              [--since TS] [--until TS] [--raw]
              查看或跟随日志，解析 CONNECT/UDP 目标并支持筛选
  latency|test  测试所有节点延迟并排序
  metrics [--format json|prom]
              输出节点状态指标（JSON 或 Prometheus）
  sub           管理订阅 (add, list, remove, update [--force])
  probe [name] [--url URL] [--json]
              Detect connectivity (ping/http) 并输出详情
  current      Show currently active node info

  doctor [--install] [--dry-run] [--without-clipboard] [--without-qrcode]
         [--without-libev]
              环境体检：检测依赖并可选自动安装

  clear         清理所有 ssctl 生成的内容（保留 nodes/）
  env [proxy [name] | noproxy]
              输出设置/清除代理环境变量的命令（配合 eval 使用）
  noproxy       停止所有代理单元并切换为直连模式（提示如何清理环境变量）
  help          查看详细说明
U
}

long_help(){
  cat <<'H'
说明：
- 单实例：start 会先停止所有正在运行的 Shadowsocks 单元，避免端口冲突。
- 默认当前节点：start/stop/show/logs/list/probe 均可不带参数，作用于 current.json 指向的节点。
- 双引擎：AEAD 算法→ rust (sslocal)；非 AEAD（如 aes-256-cfb）→ libev (ss-local)。
  * libev 模式下自动生成 _libev_<name>.json，剔除 libev 不识别的键。
- start 启动成功后会自动执行 probe；list/show/logs 有颜色高亮（可用 NO_COLOR=1 关闭）。

add：
  - 从文件导入：ssctl add <name> --from-file /path/node.json
  - 参数新建：  ssctl add <name> --server HOST --port N --method M --password P
                 [--local-port N] [--engine auto|rust|libev] [--plugin X] [--plugin-opts Y]
  - 创建后不会自动启动；若 current 未设置，会自动指向新节点。
  - 剪贴板导入的 ss:// 链接会解析并保留 plugin / plugin_opts 参数。

remove：
  - ssctl remove <name>           # 停止并删除 unit，删除 _libev_ 兼容文件，保留主配置
  - ssctl remove <name> --purge   # 以上 + 删除 nodes/<name>.json
  - 加 -y/--yes 无需确认
  - 如 current 指向被删节点，会自动清空指向。
  
  monitor：
  - ssctl monitor               # 监控 current 节点，默认每 5 秒测一次，带 DNS
  - ssctl monitor mynode --interval 2 --count 30
  - ssctl monitor --no-dns --url http://1.1.1.1 --tail
  - ssctl monitor --format json --ping          # 输出 JSON，并附加 ping 数据
  - 支持选项在前或在后；-i 等价 --interval，-n 等价 --count，-f/-t 等价 --tail
    --format 支持 text/json，--ping 额外执行系统 ping（若可用）
    --log 解析并输出最近 CONNECT/UDP 目标，可配合 --filter target=xxx
    --speed 输出 TX/RX/TOTAL(B/s) 与累计量；--stats-interval 单独控制采样周期
    --filter 支持 target/ip/port/method/protocol/regex（用于日志筛选）
    --auto-switch 在连续失败达到阈值后自动执行 ssctl switch --best
    --fail-threshold=N 设置触发 auto-switch 前允许的连续失败次数（默认 3）
    指标含义：
      OK/FAIL          是否连通（curl 返回码 & HTTP 状态）
      RTTms            time_total（ms）
      TTFB             time_starttransfer（ms）
      CONN             time_connect（ms）
      SPEED(B/s)       speed_download（字节/秒）
    “--no-dns” 用 --socks5 + 1.1.1.1 仅测链路，不测域名解析

logs：
  - ssctl log mynode --filter target=github.com --format json
  - ssctl log --follow --since "-5m" --filter protocol=udp
  - 支持 target/ip/port/method/protocol/regex 过滤；--raw 输出原始日志；无 journal 时自动回退文件日志

stats：
  - ssctl stats               # 采集当前节点速率，默认每 2 秒更新
  - ssctl stats all --aggregate --format json --interval 5
  - 输出字段：TX/RX/TOTAL(B/s)、累计 TX/RX、PID、warming 提示
  - 首次采样会提示 warming up，第二次起计算速率

metrics：
  - ssctl metrics                 # 输出 JSON 指标
  - ssctl metrics --format prom   # 输出 Prometheus 格式指标
  - 指标涵盖：节点数量、活动状态、端口、systemd unit 等

doctor：
  - ssctl doctor                    # 仅做检测与报告
  - ssctl doctor --install          # 自动安装缺失依赖（需 sudo/root）
  - ssctl doctor --install --dry-run # 预览将执行的安装命令
  - ssctl doctor --without-clipboard # 跳过 xclip/wl-paste
  - ssctl doctor --without-qrcode    # 跳过 qrencode
  - ssctl doctor --without-libev     # 跳过 libev 客户端
  - 检查内容包含：jq/curl 等核心命令、Shadowsocks 客户端、systemd --user 可用性等

env：
  - ssctl env proxy [name]
      输出将 ALL_PROXY/http_proxy/https_proxy 等指向本地 SOCKS 端口的 export 语句。
      用法：eval "$(ssctl env proxy)"   # 指向 current 节点
           eval "$(ssctl env proxy mynode)"
  - ssctl env noproxy|off
      输出清空代理环境变量的 unset 语句。
      用法：eval "$(ssctl env noproxy)"

noproxy：
  - ssctl noproxy
      停止所有 Shadowsocks 单元并清空 current 指向，进入直连模式。
      如需在当前 shell 同步关闭代理变量，执行：eval "$(ssctl env noproxy)"

JSON 关键字段：
  server, server_port, password, method,
  local_address(默认 127.0.0.1), local_port(默认 1080),
  plugin, plugin_opts（可选）
  engine（可选：auto|rust|libev，默认 auto）

配置与扩展：
  - 配置文件：~/.config/ssctl/config.json（可通过 --config 或 SSCTL_CONFIG 指定）
    示例字段：color、monitor.interval、monitor.url、doctor.include_clipboard 等。
  - 插件目录：
      • 内置：$LIB_DIR/functions.d/*.sh（随脚本安装）
      • 用户：~/.config/ssctl/functions.d/*.sh
      • 环境变量：SSCTL_PLUGIN_DIRS=dir1:dir2 指定额外目录
    插件脚本会在运行前自动载入，可定义新的 cmd_xxx 子命令。

排错：
  - 自动补全: source ssctl-completion.sh
  - 环境体检：ssctl doctor

  - 端口占用：本脚本单实例策略会先停其他 unit。
  - libev 退出：看 journalctl；或 /usr/bin/ss-local -vv -c <_libev_*.json> 前台跑。
  - 仅 IP 通但域名不通：rust 可在 JSON 配置 dns；libev 依赖系统 DNS。
H
echo "版本：${APP_VERSION}"
}


main(){
  local global_config_path="" color_override=""

  while [ $# -gt 0 ]; do
    case "$1" in
      --config)
        [ $# -ge 2 ] || die "--config 需要一个路径参数"
        global_config_path="$2"
        shift 2
        continue
        ;;
      --config=*)
        global_config_path="${1#*=}"
        shift
        continue
        ;;
      --color)
        [ $# -ge 2 ] || die "--color 需要指定 on/off/auto"
        color_override="$2"
        shift 2
        continue
        ;;
      --color=*)
        color_override="${1#*=}"
        shift
        continue
        ;;
      --no-color)
        color_override="off"
        shift
        continue
        ;;
      -v|--version)
        show_version; exit 0 ;;
      -h|--help|help)
        long_help; exit 0 ;;
      --)
        shift
        break
        ;;
      *)
        break
        ;;
    esac
  done

  load_config "$global_config_path"
  if [ -n "$color_override" ]; then
    apply_config_color "$color_override"
  else
    apply_config_color "$CONFIG_COLOR_MODE"
  fi

  load_plugins

  local cmd="${1:-}";
  shift || true
  case "${cmd:-}" in
    "" ) short_usage ;;
    add)     cmd_add "$@" ;;
    remove|rm)  cmd_remove "$@" ;;
    start)   cmd_start "${1:-}" ;;
    stop)    cmd_stop  "${1:-}" ;;
    switch)  cmd_switch "$@" ;;
    current) cmd_current ;;
    list|ls) cmd_list ;;
    show|status) cmd_show "${1:-}" ;;
    monitor) cmd_monitor "$@" ;;
    stats)   cmd_stats "$@" ;;
    log|logs)
      cmd_log "$@"
      ;;
    journal) cmd_logs "$@" ;;
    latency|test) cmd_latency "$@" ;;
    sub) cmd_sub "$@" ;;
    doctor) cmd_doctor "$@" ;;
    metrics) cmd_metrics "$@" ;;

    probe|check)
      set +e; probe "$@"; local rc=$?; set -e; exit $rc ;;
    clear)   cmd_clear ;;
    env)     cmd_env "$@" ;;
    noproxy) cmd_noproxy ;;
    -v|--version) show_version ;;
    -h|--help|help) long_help ;;
    *)
      warn "未知命令：$cmd"; short_usage; exit 1 ;;
  esac
}
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" &>/dev/null && pwd)"

resolve_lib_dir(){
  if [ -n "${SSCTL_LIB_DIR:-}" ] && [ -d "${SSCTL_LIB_DIR}/functions" ]; then
    printf '%s\n' "${SSCTL_LIB_DIR}"
    return 0
  fi
  if [ -d "${SCRIPT_DIR}/functions" ]; then
    printf '%s\n' "${SCRIPT_DIR}"
    return 0
  fi
  if [ -d "${HOME}/.local/share/ssctl/functions" ]; then
    printf '%s\n' "${HOME}/.local/share/ssctl"
    return 0
  fi
  return 1
}

if ! LIB_DIR="$(resolve_lib_dir)"; then
  printf '%s\n' "ssctl: 未找到 functions 目录，请确认已正确安装（可设置 SSCTL_LIB_DIR）" >&2
  exit 1
fi
export SSCTL_LIB_DIR="$LIB_DIR"
SCRIPT_DIR="$LIB_DIR"

LIB_CORE_DIR="${LIB_DIR}/lib"
lib_common_path="${LIB_CORE_DIR}/common.sh"
if [ ! -f "$lib_common_path" ]; then
  printf '%s\n' "ssctl: 缺少库文件 ${lib_common_path}" >&2
  exit 1
fi
# shellcheck disable=SC1090
. "$lib_common_path"

for lib_file in config service sampler_utils deps plugins utils init; do
  lib_path="${LIB_CORE_DIR}/${lib_file}.sh"
  if [ ! -f "$lib_path" ]; then
    printf '%s\n' "ssctl: 缺少库文件 ${lib_path}" >&2
    exit 1
  fi
  # shellcheck disable=SC1090
  . "$lib_path"
done

init_color_defaults
apply_color_palette
trap 'rc=$?; err "失败于: ${BASH_SOURCE[0]}:${LINENO} (函数: ${FUNCNAME[0]:-main})"; exit $rc' ERR
set -E

# Load all function scripts
for f in "${LIB_DIR}"/functions/*.sh; do
  [ -f "$f" ] || continue
  # shellcheck disable=SC1090
  . "$f"
done

self_check(){
  local required_tools=(jq systemctl curl)
  local missing=()
  for t in "${required_tools[@]}"; do
    if ! command -v "$t" >/dev/null 2>&1; then
      missing+=("$t")
    fi
  done
  if [ "${#missing[@]}" -gt 0 ]; then
    die "缺少依赖：${missing[*]}（可运行：${APP_NAME} doctor --install）"
  fi
  init_dirs
}

if [ "${SSCTL_SOURCE_ONLY:-0}" != "1" ]; then
  main "$@" || true
fi
